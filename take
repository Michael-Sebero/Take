#!/bin/bash

set -e

# Script version
SCRIPT_VERSION="1.0.0"
SCRIPT_NAME="take"

# Configuration
AUR_BASE_URL="https://aur.archlinux.org"
BUILD_DIR="${BUILD_DIR:-/tmp/aur-build-$$}"
CONFIG_DIR="$HOME/.config/take"
CACHE_DIR="$HOME/.cache/take"

# Colors for output
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    NC='\033[0m' # No Color
else
    RED='' GREEN='' YELLOW='' BLUE='' PURPLE='' CYAN='' BOLD='' NC=''
fi

# Default options
CLEAN_BUILD=false
SKIP_DEPS=false
SKIP_CONFLICTS=false
FORCE_INSTALL=false
NO_CONFIRM=true
REVIEW_PKGBUILD=false
UPDATE_PACKAGES=false
SEARCH_MODE=false
INFO_MODE=false
QUIET=false
VERBOSE=false

# Usage information
show_usage() {
    cat << EOF
$SCRIPT_NAME $SCRIPT_VERSION 

USAGE:
    $SCRIPT_NAME [OPTIONS] <packages...>
    $SCRIPT_NAME [OPTIONS] -S <packages...>    # Install packages
    $SCRIPT_NAME [OPTIONS] -Ss <query>         # Search packages
    $SCRIPT_NAME [OPTIONS] -Si <packages...>   # Show package info
    $SCRIPT_NAME [OPTIONS] -Su                 # Update AUR packages

OPTIONS:
    -S, --sync              Install packages (default)
    -Ss, --search           Search for packages
    -Si, --info             Show package information
    -Su, --sysupgrade       Update installed AUR packages
    -c, --clean             Clean build directory before building
    -d, --nodeps            Skip dependency checks
    -f, --force             Force installation (overwrite files)
    --noconfirm             Do not ask for confirmation (default)
    --confirm               Ask for confirmation before installing
    --review                Enable PKGBUILD review
    -q, --quiet             Reduce output
    -v, --verbose           Increase output
    -h, --help              Show this help message
    --version               Show version information

EXAMPLES:
    $SCRIPT_NAME wine-cachyos                  # Install wine-cachyos
    $SCRIPT_NAME -c wine-cachyos               # Clean build and install
    $SCRIPT_NAME -Ss wine                      # Search for wine packages
    $SCRIPT_NAME -Si wine-cachyos              # Show package info
    $SCRIPT_NAME -Su                           # Update all AUR packages
EOF
}

# Logging functions
log_info() {
    if [[ "$QUIET" != true ]]; then
        echo -e "${BLUE}::${NC} $1"
    fi
}

log_success() {
    if [[ "$QUIET" != true ]]; then
        echo -e "${GREEN}::${NC} $1"
    fi
}

log_warning() {
    echo -e "${YELLOW}:: WARNING:${NC} $1" >&2
}

log_error() {
    echo -e "${RED}:: ERROR:${NC} $1" >&2
}

log_debug() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${CYAN}:: DEBUG:${NC} $1" >&2
    fi
}

# Detect privilege escalation method
detect_privilege_escalation() {
    if command -v doas >/dev/null 2>&1; then
        echo "doas"
    elif command -v sudo >/dev/null 2>&1; then
        echo "sudo"
    else
        log_error "Neither sudo nor doas found. Please install one of them."
        exit 1
    fi
}

PRIV_ESC=$(detect_privilege_escalation)
log_debug "Using privilege escalation: $PRIV_ESC"

# Wrapper for privilege escalation
run_as_root() {
    if [[ "$EUID" -eq 0 ]]; then
        "$@"
    else
        case "$PRIV_ESC" in
            "doas")
                doas "$@"
                ;;
            "sudo")
                sudo "$@"
                ;;
        esac
    fi
}

# Find suitable build user
find_build_user() {
    local build_user
    if [[ "$EUID" -eq 0 ]]; then
        # Running as root, find a regular user
        build_user=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $7 !~ /nologin|false/ { print $1; exit }')
        if [[ -n "$build_user" ]]; then
            echo "$build_user"
        elif [[ -n "$SUDO_USER" ]]; then
            echo "$SUDO_USER"
        else
            echo "nobody"
        fi
    else
        echo "$USER"
    fi
}

BUILD_USER=$(find_build_user)
log_debug "Build user: $BUILD_USER"

# Check if package exists in AUR
check_aur_package() {
    local package="$1"
    local url="https://aur.archlinux.org/rpc/?v=5&type=info&arg=$package"
    
    if ! curl -s "$url" | grep -q '"resultcount":1'; then
        return 1
    fi
    return 0
}

# Get package info from AUR
get_aur_info() {
    local package="$1"
    local url="https://aur.archlinux.org/rpc/?v=5&type=info&arg=$package"
    curl -s "$url"
}

# Search AUR packages
search_aur() {
    local query="$1"
    local url="https://aur.archlinux.org/rpc/?v=5&type=search&arg=$query"
    
    log_info "Searching AUR for: $query"
    local results=$(curl -s "$url")
    
    if ! echo "$results" | grep -q '"resultcount":[1-9]'; then
        log_warning "No packages found matching: $query"
        return 1
    fi
    
    echo "$results" | jq -r '.results[] | "\(.Name) \(.Version)\n    \(.Description)"' 2>/dev/null || {
        log_error "Failed to parse search results. Is jq installed?"
        return 1
    }
}

# Show package info
show_package_info() {
    local package="$1"
    
    if ! check_aur_package "$package"; then
        log_error "Package '$package' not found in AUR"
        return 1
    fi
    
    local info=$(get_aur_info "$package")
    
    echo "$info" | jq -r '
        .results[0] | 
        "Repository      : aur",
        "Name            : \(.Name)",
        "Version         : \(.Version)",
        "Description     : \(.Description // "None")",
        "URL             : \(.URL // "None")",
        "Maintainer      : \(.Maintainer // "Orphaned")",
        "First Submitted : \(.FirstSubmitted | strftime("%Y-%m-%d %H:%M:%S"))",
        "Last Modified   : \(.LastModified | strftime("%Y-%m-%d %H:%M:%S"))",
        "Out of Date     : \(if .OutOfDate then "Yes" else "No" end)",
        "Votes           : \(.NumVotes)",
        "Popularity      : \(.Popularity)"
    ' 2>/dev/null || {
        log_error "Failed to parse package info. Is jq installed?"
        return 1
    }
}

# Create build directory
setup_build_dir() {
    local package="$1"
    local temp_dir="$BUILD_DIR/$package"
    
    if [[ "$CLEAN_BUILD" == true ]] && [[ -d "$temp_dir" ]]; then
        log_info "Cleaning previous build directory for $package"
        rm -rf "$temp_dir"
    fi
    
    mkdir -p "$temp_dir"
    echo "$temp_dir"
}

# Review PKGBUILD
review_pkgbuild() {
    local pkgbuild_path="$1"
    
    if [[ "$REVIEW_PKGBUILD" != true ]]; then
        return 0
    fi
    
    echo -e "${YELLOW}:: PKGBUILD Review${NC}"
    echo "Please review the PKGBUILD and any other files:"
    echo "  $pkgbuild_path"
    echo
    
    if command -v ${EDITOR:-nano} >/dev/null 2>&1; then
        read -p "Review PKGBUILD? [Y/n] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            ${EDITOR:-nano} "$pkgbuild_path"
        fi
    else
        echo "Contents of PKGBUILD:"
        cat "$pkgbuild_path"
        echo
    fi
    
    read -p "Proceed with build? [Y/n] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        log_warning "Build cancelled by user"
        return 1
    fi
    
    return 0
}

# Extract dependencies from PKGBUILD
extract_dependencies() {
    local pkgbuild="$1"
    
    # Source the PKGBUILD in a subshell to extract dependencies
    (
        source "$pkgbuild" 2>/dev/null
        
        # Combine all dependency arrays
        local all_deps=()
        [[ -n "${depends[*]}" ]] && all_deps+=("${depends[@]}")
        [[ -n "${makedepends[*]}" ]] && all_deps+=("${makedepends[@]}")
        [[ -n "${checkdepends[*]}" ]] && all_deps+=("${checkdepends[@]}")
        
        # Clean up dependency names (remove version constraints)
        for dep in "${all_deps[@]}"; do
            # Remove version constraints like >=1.0, =1.0, <1.0, etc.
            dep=$(echo "$dep" | sed 's/[<>=].*$//')
            echo "$dep"
        done | sort -u
    )
}

# Install package dependencies
install_package_dependencies() {
    local pkgbuild="$1"
    
    if [[ "$SKIP_DEPS" == true ]]; then
        log_debug "Skipping dependency installation"
        return 0
    fi
    
    log_info "Checking dependencies..."
    
    # Extract dependencies from PKGBUILD
    local deps_array=()
    while IFS= read -r dep; do
        [[ -n "$dep" ]] && deps_array+=("$dep")
    done < <(extract_dependencies "$pkgbuild")
    
    if [[ ${#deps_array[@]} -eq 0 ]]; then
        log_debug "No dependencies found"
        return 0
    fi
    
    log_debug "Found dependencies: ${deps_array[*]}"
    
    # Check which dependencies are missing
    local missing_deps=()
    for dep in "${deps_array[@]}"; do
        if ! pacman -Q "$dep" >/dev/null 2>&1; then
            # Check if it's available in repos
            if pacman -Si "$dep" >/dev/null 2>&1; then
                missing_deps+=("$dep")
            else
                log_debug "Dependency '$dep' not found in repositories, might be AUR package"
            fi
        fi
    done
    
    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        log_success "All dependencies already satisfied"
        return 0
    fi
    
    log_info "Installing missing dependencies: ${missing_deps[*]}"
    
    local pacman_args="-S --noconfirm"
    if ! run_as_root pacman $pacman_args "${missing_deps[@]}"; then
        log_error "Failed to install dependencies"
        return 1
    fi
    
    log_success "Dependencies installed successfully"
    return 0
}

# Build and install package
build_and_install_package() {
    local package="$1"
    local temp_dir
    
    log_info "Processing package: $package"
    
    # Check if package exists in AUR
    if ! check_aur_package "$package"; then
        log_error "Package '$package' not found in AUR"
        return 1
    fi
    
    # Setup build directory
    temp_dir=$(setup_build_dir "$package")
    cd "$temp_dir"
    
    # Cleanup function
    cleanup_package() {
        if [[ -d "$temp_dir" ]]; then
            rm -rf "$temp_dir"
        fi
    }
    
    # Clone AUR repository
    log_info "Cloning AUR repository for $package..."
    local aur_url="$AUR_BASE_URL/${package}.git"
    
    if ! git clone "$aur_url" "$package"; then
        log_error "Failed to clone AUR repository for $package"
        cleanup_package
        return 1
    fi
    
    cd "$package"
    
    # Review PKGBUILD
    if ! review_pkgbuild "PKGBUILD"; then
        cleanup_package
        return 1
    fi
    
    # Install dependencies before building
    if ! install_package_dependencies "PKGBUILD"; then
        log_error "Failed to install dependencies for $package"
        cleanup_package
        return 1
    fi
    
    # Set proper ownership if running as root
    if [[ "$EUID" -eq 0 ]] && [[ "$BUILD_USER" != "root" ]]; then
        chown -R "$BUILD_USER:$(id -gn "$BUILD_USER")" "$temp_dir"
    fi
    
    # Build package
    log_info "Building package $package..."
    
    # Always use --nodeps since we handle dependencies ourselves
    # This prevents makepkg from trying to use sudo -k
    local makepkg_args="-sf --nodeps --noconfirm"
    
    local build_cmd
    if [[ "$EUID" -eq 0 ]] && [[ "$BUILD_USER" != "root" ]]; then
        if command -v runuser >/dev/null 2>&1; then
            build_cmd="runuser -u $BUILD_USER -- makepkg $makepkg_args"
        elif [[ "$BUILD_USER" != "nobody" ]]; then
            build_cmd="su - $BUILD_USER -c 'cd \"$temp_dir/$package\" && makepkg $makepkg_args'"
        else
            build_cmd="makepkg $makepkg_args --asroot"
        fi
    else
        build_cmd="makepkg $makepkg_args"
    fi
    
    log_debug "Build command: $build_cmd"
    
    if ! eval "$build_cmd"; then
        log_error "Failed to build package $package"
        cleanup_package
        return 1
    fi
    
    # Find built package
    local package_file
    package_file=$(find . -name "*.pkg.tar.*" -type f | head -1)
    
    if [[ -z "$package_file" ]]; then
        log_error "No package file found after building $package"
        cleanup_package
        return 1
    fi
    
    # Install package
    log_info "Installing package $package..."
    
    local pacman_args="-U --noconfirm"
    if [[ "$FORCE_INSTALL" == true ]]; then
        pacman_args+=" --force"
    fi
    
    if ! run_as_root pacman $pacman_args "$package_file"; then
        log_error "Failed to install package $package"
        cleanup_package
        return 1
    fi
    
    log_success "Package $package installed successfully"
    cleanup_package
    return 0
}

# Update AUR packages
update_aur_packages() {
    log_info "Checking for AUR package updates..."
    
    # Get list of installed AUR packages
    local aur_packages=()
    while IFS= read -r line; do
        local package=$(echo "$line" | awk '{print $1}')
        if check_aur_package "$package"; then
            aur_packages+=("$package")
        fi
    done < <(pacman -Qm)
    
    if [[ ${#aur_packages[@]} -eq 0 ]]; then
        log_success "No AUR packages installed"
        return 0
    fi
    
    log_info "Found ${#aur_packages[@]} AUR packages installed"
    
    # Check for updates
    local updates_available=()
    for package in "${aur_packages[@]}"; do
        local installed_version=$(pacman -Q "$package" | awk '{print $2}')
        local aur_info=$(get_aur_info "$package")
        local aur_version=$(echo "$aur_info" | jq -r '.results[0].Version' 2>/dev/null)
        
        if [[ "$aur_version" != "$installed_version" ]] && [[ "$aur_version" != "null" ]]; then
            updates_available+=("$package")
            log_info "Update available: $package $installed_version -> $aur_version"
        fi
    done
    
    if [[ ${#updates_available[@]} -eq 0 ]]; then
        log_success "All AUR packages are up to date"
        return 0
    fi
    
    log_info "Found ${#updates_available[@]} package(s) with updates available"
    
    if [[ "$NO_CONFIRM" != true ]]; then
        echo "Packages to update: ${updates_available[*]}"
        read -p "Proceed with update? [Y/n] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            log_warning "Update cancelled by user"
            return 1
        fi
    fi
    
    # Update packages
    local failed_updates=()
    for package in "${updates_available[@]}"; do
        if ! build_and_install_package "$package"; then
            failed_updates+=("$package")
        fi
    done
    
    if [[ ${#failed_updates[@]} -gt 0 ]]; then
        log_error "Failed to update: ${failed_updates[*]}"
        return 1
    fi
    
    log_success "All updates completed successfully"
    return 0
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -S|--sync)
                # Default mode, nothing to change
                shift
                ;;
            -Ss|--search)
                SEARCH_MODE=true
                shift
                ;;
            -Si|--info)
                INFO_MODE=true
                shift
                ;;
            -Su|--sysupgrade)
                UPDATE_PACKAGES=true
                shift
                ;;
            -c|--clean)
                CLEAN_BUILD=true
                shift
                ;;
            -d|--nodeps)
                SKIP_DEPS=true
                shift
                ;;
            -f|--force)
                FORCE_INSTALL=true
                shift
                ;;
            --noconfirm)
                # Already default, but keep for compatibility
                shift
                ;;
            --confirm)
                NO_CONFIRM=false
                shift
                ;;
            --review)
                REVIEW_PKGBUILD=true
                shift
                ;;
            --noreview)
                REVIEW_PKGBUILD=false
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            --version)
                echo "$SCRIPT_NAME $SCRIPT_VERSION"
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Remaining arguments are packages
    PACKAGES=("$@")
}

# Main function
main() {
    # Create necessary directories
    mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
    
    # Parse arguments
    parse_arguments "$@"
    
    # Handle different modes
    if [[ "$UPDATE_PACKAGES" == true ]]; then
        update_aur_packages
        exit $?
    fi
    
    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        log_error "No packages specified"
        show_usage
        exit 1
    fi
    
    if [[ "$SEARCH_MODE" == true ]]; then
        for query in "${PACKAGES[@]}"; do
            search_aur "$query"
        done
        exit 0
    fi
    
    if [[ "$INFO_MODE" == true ]]; then
        for package in "${PACKAGES[@]}"; do
            show_package_info "$package"
            echo
        done
        exit 0
    fi
    
    # Install mode (default)
    local successful_packages=()
    local failed_packages=()
    
    log_info "Installing ${#PACKAGES[@]} AUR package(s)..."
    
    for package in "${PACKAGES[@]}"; do
        if build_and_install_package "$package"; then
            successful_packages+=("$package")
        else
            failed_packages+=("$package")
        fi
    done
    
    # Summary
    if [[ ${#successful_packages[@]} -gt 0 ]]; then
        log_success "Successfully installed: ${successful_packages[*]}"
    fi
    
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        log_error "Failed to install: ${failed_packages[*]}"
        exit 1
    fi
    
    log_success "All packages installed successfully!"
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    # Required commands
    local required_commands=("git" "curl" "jq")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        log_info "Please install them with: pacman -S ${missing_deps[*]}"
        exit 1
    fi
}

# Initialize
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    check_dependencies
    main "$@"
fi
